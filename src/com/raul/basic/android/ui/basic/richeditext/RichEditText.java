package com.raul.basic.android.ui.basic.richeditext;import java.util.regex.Matcher;import android.content.Context;import android.text.Editable;import android.util.AttributeSet;/** * 富文本 *  * @author xiaomiaomiao *  */public class RichEditText extends LimitedEditText {	/**	 * 文本观察者	 */	private RichEditTextWatcher mTextWatcher;	/**	 * 是否已装载文本观察器	 */	private boolean mLoadedTextWatcher = false;	/**	 * constructor()	 * 	 * @param context	 *            context	 */	public RichEditText(Context context) {		super(context);		loadTextWatcher();	}	/**	 * constructor()	 * 	 * @param context	 *            context	 * @param attrs	 *            attrs	 */	public RichEditText(Context context, AttributeSet attrs) {		super(context, attrs);		loadTextWatcher();	}	/**	 * constructor()	 * 	 * @param context	 *            context	 * @param attrs	 *            attrs	 * @param defStyle	 *            defStyle	 */	public RichEditText(Context context, AttributeSet attrs, int defStyle) {		super(context, attrs, defStyle);		loadTextWatcher();	}	/**	 * 装载文本观察者	 */	protected void loadTextWatcher() {		// 文本观察者已装载则直接返回		if (mLoadedTextWatcher) {			return;		}		// 如果伪装在则重新装载		if (mTextWatcher == null) {			mTextWatcher = new RichEditTextWatcher(getContext());		}		// 设置标志位true		mLoadedTextWatcher = true;		// 添加监听		addTextChangedListener(mTextWatcher);	}	/**	 * 卸载文本观察者	 */	protected void unloadTextWatcher() {		if (!mLoadedTextWatcher) {			return;		}		if (mTextWatcher == null) {			return;		}		removeTextChangedListener(mTextWatcher);		mLoadedTextWatcher = false;	}	/**	 * 文本观察者	 */	private static class RichEditTextWatcher implements			android.text.TextWatcher {		/**		 * 表情标志		 */		private boolean mIsExpression = false;		/**		 * 文本开端和尾端		 */		private int mStart, mEnd;		/**		 * 附加标志		 */		private boolean mReAppend = false;		/**		 * 替换文本		 */		private String mReplace;		/**		 * 继续标志		 */		private boolean willContinue = true;		/**		 * 场景成员变量		 */		private Context mContext;		private RichEditTextWatcher(Context context) {			this.mContext = context;		}		/**		 * beforeTextChanged		 * 		 */		@Override		public void beforeTextChanged(CharSequence charSequence, int start,				int count, int after) {			if (!willContinue) {				return;			}			mIsExpression = false;			if (count == 1 && after == 0) {				String cut = String.valueOf(charSequence).substring(0,						start + 1);				int index = cut.lastIndexOf('[');				if (index > -1) {					String subCut = cut.substring(index);					if (ChatTextParser.getInstance(mContext)							.getEmotionPattern().matcher(subCut).matches()) {						// 为表情						mIsExpression = true;						mStart = index;						mEnd = start;					}				}			}		}		/**		 * onTextChanged		 */		@Override		public void onTextChanged(CharSequence s, int start, int before,				int count) {			if (!willContinue) {				return;			}			mReAppend = false;			if (count > 0) {				mReplace = String.valueOf(s).substring(start, start + count);				Matcher matcher = ChatTextParser.getInstance(mContext)						.getEmotionPattern().matcher(mReplace);				if (matcher.find()) {					mReAppend = true;					mStart = start;				}			}		}		/**		 * afterTextChanged		 * 		 * @param s		 *            s		 * @see android.text.TextWatcher#afterTextChanged(android.text.Editable)		 */		@Override		public void afterTextChanged(Editable s) {			if (mIsExpression) {				s.delete(mStart, mEnd);				mIsExpression = false;			} else if (mReAppend) {				willContinue = false;				mReAppend = false;				s.delete(mStart, mStart + mReplace.length());				s.insert(mStart, ChatTextParser.getInstance(mContext)						.parseText(mReplace, mContext));				willContinue = true;			}		}	}	/**	 * 设置最大长度	 * 	 */	@Override	public void setMaxCharLength(int maxCharLength) {		super.setMaxCharLength(maxCharLength);	}}